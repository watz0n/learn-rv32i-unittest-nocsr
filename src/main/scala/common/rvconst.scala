//=======================================================================
// RISCV, A Simple As Possible Core
// Watson Huang
// Dec 18, 2016
// 
// Declare all constant for rvcore
//=======================================================================
package rvcommon

import chisel3._
import chisel3.util._

trait rvspec {
    val xlen = 32       //x register bits, SPEC Vol.I Ch2.1
    val xrsz = 32       //x register size, SPEC Vol.I Figure 2.1
    //val xext = "I"      //Encoding of Extension, SPEC Vol.II Table 3.2
    //val vmem = false
    //val NOP = UInt(0x00000013, xlen) //NOP Instruction, SPEC Vol.I Ch2.4
}

trait rvdef {
    val opbl = 0
    val opbh = 6
    val rdbl = 7
    val rdbh = 11
    val rs1bl = 15
    val rs1bh = 19
    val rs2bl = 20
    val rs2bh = 24
    val shamtsz = 5 //shift amount bit size
}

trait rvinst {
    //LUI/AUIPC instructions, RV32I Base Instruction Set List up to down order
    val LUI     = BitPat("b?????????????????????????0110111")
    val AUIPC   = BitPat("b?????????????????????????0010111")
    //Jump instructions, RV32I Base Instruction Set List up to down order
    val JAL     = BitPat("b?????????????????????????1101111")
    val JALR    = BitPat("b?????????????????000?????1100111")
    //Branch instructions, RV32I Base Instruction Set List up to down order
    val BEQ     = BitPat("b?????????????????000?????1100011")
    val BNE     = BitPat("b?????????????????001?????1100011")
    val BLT     = BitPat("b?????????????????100?????1100011")
    val BGE     = BitPat("b?????????????????101?????1100011")
    val BLTU    = BitPat("b?????????????????110?????1100011")
    val BGEU    = BitPat("b?????????????????111?????1100011")
    //Load/Store instructions, RV32I Base Instruction Set List up to down orde
    val LB      = BitPat("b?????????????????000?????0000011")
    val LH      = BitPat("b?????????????????001?????0000011")
    val LW      = BitPat("b?????????????????010?????0000011")
    val LBU     = BitPat("b?????????????????100?????0000011")
    val LHU     = BitPat("b?????????????????101?????0000011")
    val SB      = BitPat("b?????????????????000?????0100011")
    val SH      = BitPat("b?????????????????001?????0100011")
    val SW      = BitPat("b?????????????????010?????0100011")
    //For Reg-Reg instructions, RV32I Base Instruction Set List up to down order
    val ADD     = BitPat("b0000000??????????000?????0110011")
    val SUB     = BitPat("b0100000??????????000?????0110011")
    val SLL     = BitPat("b0000000??????????001?????0110011")
    val SLT     = BitPat("b0000000??????????010?????0110011")
    val SLTU    = BitPat("b0000000??????????011?????0110011")
    val XOR     = BitPat("b0000000??????????100?????0110011")
    val SRL     = BitPat("b0000000??????????101?????0110011")
    val SRA     = BitPat("b0100000??????????101?????0110011")
    val OR      = BitPat("b0000000??????????110?????0110011")
    val AND     = BitPat("b0000000??????????111?????0110011")
    //For Reg-Imm instructions, RV32I Base Instruction Set List up to down order
    val ADDI     = BitPat("b?????????????????000?????0010011")
    val SLTI     = BitPat("b?????????????????010?????0010011")
    val SLTIU    = BitPat("b?????????????????011?????0010011")
    val XORI     = BitPat("b?????????????????100?????0010011")
    val ORI      = BitPat("b?????????????????110?????0010011")
    val ANDI     = BitPat("b?????????????????111?????0010011")
    val SLLI     = BitPat("b0000000??????????001?????0010011")
    val SRLI     = BitPat("b0000000??????????101?????0010011")
    val SRAI     = BitPat("b0100000??????????101?????0010011")
}

trait rvalu {
    val X = UInt(0xF, 4) //Use non-exist op for debug
    val ADD = UInt(0, 4) //value as Verilog style: {funct7[5], funct3[2:0]} = 4'b0000
    val SUB = UInt(8, 4) //{funct7[5], funct3[2:0]} = 4'b1000
    val SLL = UInt(1, 4)
    val SLT = UInt(2, 4)
    val SLTU = UInt(3, 4)
    val XOR = UInt(4, 4)
    val SRL = UInt(5, 4)
    val SRA = UInt(0xD, 4) //{funct7[5], funct3[2:0]} = 4'b1101
    val OR = UInt(6, 4)
    val AND = UInt(7, 4)
    val CP1 = UInt(0xA, 4) //Copy RS1
    val CP2 = UInt(0xB, 4) //Copy RS2
}

object rvspec extends rvspec
object rvinst extends rvinst with rvdef
object rvalu extends rvalu

package rvdp {
    
    object op2_sel {
        val X = UInt(7,3) //Default
        val R = UInt(0,3) //R-Type, Register
        val I = UInt(1,3) //I-Type, Imm.
        val S = UInt(2,3) //S-Type, Store Inst.
        val B = UInt(3,3) //SB-Type, Branch Inst.
        val U = UInt(4,3) //U-Type, LUI, AUIPC
        val J = UInt(5,3) //UJ-Type, JAL
    }

    object reg_wren {
        val X = UInt(0,1)
        val N = UInt(0,1) //No
        val Y = UInt(1,1) //Yes
    }

    object mem_wren {
        val X = UInt(0,1)
        val N = UInt(0,1) //No
        val Y = UInt(1,1) //Yes
    }

    object mem_en {
        val X = UInt(0,1)
        val N = UInt(0,1) //No
        val Y = UInt(1,1) //Yes
    }

    object wb_sel {
        val X = UInt(0,2)
        val ALU = UInt(0,2)
        val MEM = UInt(1,2)
        val PC4 = UInt(2,2)
    }

    object mem_type {
        val X = UInt(2,3)
        val B = UInt(0,3)
        val H = UInt(1,3)
        val W = UInt(2,3)
        val BU = UInt(4,3)
        val HU = UInt(5,3)
    }

    object pc_sel {
        val X = UInt(0,2)
        val A4 = UInt(0,2) //Add 4
        val BR = UInt(1,2) //Branch
        val JP = UInt(2,2) //Jump JAL/JALR
    }

    object br_sel {
        val X = UInt(7, 3)
        val BEQ = UInt(0, 3)
        val BNE = UInt(1, 3)
        val BLT = UInt(2, 3)
        val BGE = UInt(3, 3)
        val BLTU = UInt(4, 3)
        val BGEU = UInt(5, 3)
    }

    object op1_sel { //Add this support JAL function to decrease an adder
        val X = UInt(0, 1)
        val R = UInt(0, 1) //RS1
        val P = UInt(1, 1) //PC
    }
}